<!DOCTYPE html>
<html>
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
<!--
        <link type="text/css" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css"/>
        <link type="text/css" rel="stylesheet" href="https://unpkg.com/maptalks/dist/maptalks.css"/>

        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/three.js/88/three.min.js"></script>
        <script type="text/javascript" src='http://threejs.org/examples/js/controls/OrbitControls.js'></script>

        <script type="text/javascript" src="//cdn.rawgit.com/Mikhus/canvas-gauges/gh-pages/download/2.1.4/all/gauge.min.js"></script>
        <script type="text/javascript" src="https://unpkg.com/maptalks/dist/maptalks.min.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/smoothie/1.32.0/smoothie.min.js"></script>
-->

        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
        <link type="text/css" rel="stylesheet" href="font-awesome.min.css"/>
        <link type="text/css" rel="stylesheet" href="maptalks.css"/>

        <script type="text/javascript" src="three.min.js"></script>
        <script type="text/javascript" src="OrbitControls.js"></script>
        <script type="text/javascript" src="ColladaLoader.js"></script>

        <script type="text/javascript" src="gauge.min.js"></script>
        <script type="text/javascript" src="maptalks.min.js"></script>
        <script type="text/javascript" src="smoothie.min.js"></script>

        <script src="libcluon-0.0.51.js"></script>

        <style>
            body, html {
                height: 100%;
                margin: 0;
            }

            * {
              box-sizing: border-box;
            }

            .bg {
                background-image: url("car.jpg");
                height: 100%;
                background-position: center;
                background-repeat: no-repeat;
                background-size: cover;
            }

            .main {
              float:left;
              width:70%;
              padding:2px 2px;
              margin-top:10px;
              margin-left:10px;
            }

            .right {
              float:right;
              width:20%;
              padding:2px 2px;
              margin-top:10px;
              margin-left:10px;
            }

            .element {
              margin-top:10px;
              margin-left:10px;
              box-shadow: 3px 3px 3px #aaaaaa;
            }

            .elementNoShadow {
            }

            .module > header {
              position: absolute;
              bottom: 0;
              left: 0;
              width: 100%;
              padding: 20px 10px;
              background: inherit;
              background-attachment: fixed;
            }
            .module > header > h1 {
              margin: 0;
              font-family: Awesome;
              color: white;
              position: relative;
              z-index: 1;
            }

            div.smoothie-chart-tooltip {
              background: #444;
              padding: 1em;
              margin-top: 20px;
              font-family: Awesome;
              color: white;
              font-size: 10px;
              pointer-events: none;
            }

            #map { width: 220px; height: 220px;  }

            ul.fancytree-container {
              margin: 4px;
              width: 300px;
              height: 200px;
              overflow: auto;
              position: relative;
            }

            @media only screen and (max-width:800px) {
              /* For tablets: */
              .main {
                width:80%;
              }
              .right {
                width:100%;
              }
            }
            @media only screen and (max-width:500px) {
              /* For mobile phones: */
              .main, .right {
                width:100%;
              }
            }
        </style>
    </head>

<body class="bg" style="font-family:Awesome;">

<div class="container-fluid">
    <div class="row py-5">
        <div class="col-12 d-flex justify-content-center">
            <h1 style="color:white;">Vehicle view</h1>
        </div>
    </div>
    <div class="row ">
        <!--<div class="col-xs-12 col-md-5 d-flex justify-content-center">-->
            <!--<div class="main">-->
                <!--<div class="elementNoShadow">-->
                    <!--<center>-->
                        <!--<div id="ego-3dview"></div>-->
                    <!--</center>-->
                <!--</div>-->
            <!--</div>-->
        <!--</div>-->
        <div class="col-xs-12 col-md-10 d-flex justify-content-center">
            <div class="main">
                <div class="elementNoShadow">
                    <center>
                        <div id="3d-map"></div>
                    </center>
                </div>
            </div>
        </div>
        <div class="col-xs-12 col-md-2 d-flex flex-column justify-content-center">
             
                    <div class="card">
                            <div class="card-body">
                                <center>
                                    <i id="connectionStatusSymbol" class="fa fa-taxi" style="font-size:30px;color:#555"></i>
                                    <div id="connectionStatusText">disconnected</div>
                                </center>
                            </div>
                          </div>
                          currentIndex <div class="card">
                                <div class="card-body">
                                        <center>
                                                <canvas id="speed"></canvas>
                                                </center>
                                </div>
                              </div>
                    <div class="card">
                            <div class="card-body">
                                    <center>
                                            <div id="map"></div>
                                            </center>
                            </div>
                        </div>
                        <div class="card">
                                <div class="card-body">
                                        <center>
                                                <canvas id="cpu-load" width="220" height="100"></canvas>
                                                </center>
                                </div>
                              </div>
                    
        </div>
    </div>


   
</div>





</body>

<script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>

<!--<script>-->
    <!--var scene = new THREE.Scene();-->

    <!--var car;-->

    <!--var loadingManager = new THREE.LoadingManager( function() {-->
        <!--scene.add( car );-->
    <!--} );-->
    <!--// collada-->
    <!--var loader = new THREE.ColladaLoader( loadingManager );-->
    <!--loader.load( 'car.dae', function ( collada ) {-->
        <!--car = collada.scene;-->
    <!--} );-->


    <!--var renderer = new THREE.WebGLRenderer();-->
    <!--renderer.setSize( 700, 500 );-->
    <!--renderer.setClearColor(new THREE.Color(0x00000000));-->
    <!--document.getElementById('ego-3dview').appendChild(renderer.domElement);-->

    <!--var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );-->
    <!--camera.position.y = 5;-->
    <!--camera.position.z = 5;-->
    <!--camera.lookAt (new THREE.Vector3(0, 0, 0));-->
    <!--scene.add (camera);-->


    <!--var controls = new THREE.OrbitControls(camera, renderer.domElement);-->


    <!--var pointLight = new THREE.PointLight(0xffffff);-->
    <!--pointLight.position.set (0, 20, 20);-->
    <!--scene.add (pointLight);-->
    <!---->
    <!--var ambientLight = new THREE.AmbientLight (0xaaaaaa);-->
    <!--scene.add(ambientLight);-->


    <!--var gridXZ = new THREE.GridHelper(50, 50, 0xff0000, 0xffffff);-->
    <!--scene.add(gridXZ);-->


    <!--// point_cloud-->
    <!--var geometry_pointcloud = new THREE.BufferGeometry();-->
    <!--var MAX_POINTS = 63000;-->
    <!--var positions = new Float32Array(MAX_POINTS * 3); // 3 vertices per point-->
    <!--positions.fill(0);-->
    <!--geometry_pointcloud.addAttribute('position', new THREE.BufferAttribute(positions, 3));-->
    <!--var material_pointcloud = new THREE.PointsMaterial( { color: 0x0000ff, size: 0.02 } );-->
    <!--var particles_pointcloud = new THREE.Points( geometry_pointcloud, material_pointcloud );-->
    <!--scene.add( particles_pointcloud );-->

    <!--var animate = function () {-->
        <!--requestAnimationFrame( animate );-->
        <!--renderer.render(scene, camera);-->
    <!--};-->

    <!--animate();-->
<!--</script>-->

<script>
    var scene = new THREE.Scene();

    // var car;
    //
    // var loadingManager = new THREE.LoadingManager( function() {
    //     scene.add( car );
    //     } );
    // var loader = new THREE.ColladaLoader( loadingManager );
    // loader.load( 'car.dae', function ( collada ) {
    //     car = collada.scene;
    //     } );


    var renderer = new THREE.WebGLRenderer();
    renderer.setSize( 700, 500 );
    renderer.setClearColor(new THREE.Color(0x00000000));
    document.getElementById('3d-map').appendChild(renderer.domElement);

    var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );
    camera.position.y = 5;
    camera.position.z = 5;
    camera.lookAt (new THREE.Vector3(0, 0, 0));
    scene.add (camera);


    var controls = new THREE.OrbitControls(camera, renderer.domElement);


    var pointLight = new THREE.PointLight(0xffffff);
    pointLight.position.set (0, 20, 20);
    scene.add (pointLight);

    var ambientLight = new THREE.AmbientLight (0xaaaaaa);
    scene.add(ambientLight);


    //
    var pointCloud = new THREE.BufferGeometry();
    var carPoints = new THREE.BufferGeometry();
    var MAX_POINTS = 150000;

    var pointPositions = new Float32Array(MAX_POINTS * 3); // 3 vertices per
    var carPositions = new Float32Array(3000 * 3); // 3 vertices per

    pointPositions.fill(0);
    carPositions.fill(0);

    pointCloud.addAttribute('position', new THREE.BufferAttribute(pointPositions, 3));
    carPoints.addAttribute('position', new THREE.BufferAttribute(carPositions, 3));

    var pointCloudMaterial = new THREE.PointsMaterial( { color: 0xffffff, size: 0.02 } );
    var carMaterial = new THREE.PointsMaterial( { color: 0xff0000, size: 0.1 } );

    var pointCloud = new THREE.Points( pointCloud, pointCloudMaterial );
    var carPointCloud = new THREE.Points( carPoints, carMaterial );

    scene.add( pointCloud );
    scene.add( carPointCloud );

    var currentIndex = 0;
    var currentCarIndex = 0;

    var animate = function ()
    {
        requestAnimationFrame( animate );
        renderer.render(scene, camera);
    };

    animate();

</script>

<script>
    var insertCarPoints = function(carPoint)
    {
        var positions = carPointCloud.geometry.attributes.position.array;
        positions[currentCarIndex++] = carPoint.x;
        positions[currentCarIndex++] = carPoint.y;
        positions[currentCarIndex++] = carPoint.z;
        carPointCloud.geometry.attributes.position.needsUpdate = true;
    };

    var insertMapPoints = function(mapPoints)
    {
        var positions = pointCloud.geometry.attributes.position.array;
        for(var i in mapPoints)
        {
            positions[currentIndex++] = mapPoints[i].x;
            positions[currentIndex++] = mapPoints[i].y;
            positions[currentIndex++] = mapPoints[i].z;
        }
        pointCloud.geometry.attributes.position.needsUpdate = true;
    };
    var floatArrayFromString = function(inString, precision, delimiter){
        var mapCoordinatesParsed = [];
        var i = 0;
        while(i < inString.length)
        {
            if(inString[i] === '-')
            {
                var beforeDecimal =  inString.substring(i,i+inString.substring(i).indexOf('.'));
                    var endOfNumber = inString.substring(i+beforeDecimal.length, i+beforeDecimal.length + precision + '.'.length);
                mapCoordinatesParsed.push(parseFloat(beforeDecimal+endOfNumber));
                i += beforeDecimal.length + endOfNumber.length + delimiter.length;
            }
            else
            {
                var beforeDecimal =  inString.substring(i,i+inString.substring(i).indexOf('.'));
                var endOfNumber = inString.substring(i+beforeDecimal.length, i+beforeDecimal.length + precision + '.'.length);
                mapCoordinatesParsed.push(parseFloat(beforeDecimal+endOfNumber));
                i += beforeDecimal.length + endOfNumber.length + delimiter.length;
            }
        }
        return mapCoordinatesParsed;
    }
    var mapPointsArrayFromFloatArray = function(in_array){
        var mappoints = [];
        for (var i = 0; i < in_array.length; i += 3)
        {
            var mappoint = {};
            mappoint.x = in_array[i];
            mappoint.y = in_array[i+1];
            mappoint.z = in_array[i+2];
            mappoints.push(mappoint);
        }
        return mappoints;
    }
</script>

<script>

    var __libcluon = libcluon();

    function getResourceFrom(url)
    {
        var xmlHttp = new XMLHttpRequest();
        xmlHttp.open("GET", url, false /*asynchronous request*/);
        xmlHttp.send(null);
        return xmlHttp.responseText;
    }

    if ("WebSocket" in window) {
        var ws = new WebSocket("ws://" + window.location.host + "/");
        ws.binaryType = 'arraybuffer';

        ws.onopen = function() {
            console.log("Connected...");
            document.getElementById("connectionStatusSymbol").style.color = "#3CB371";
            document.getElementById("connectionStatusText").style.color = "#3CB371";
            document.getElementById("connectionStatusText").innerHTML = "connected";
            var odvd = getResourceFrom("opendlv-standard-message-set-v0.9.1.odvd");
            console.log("Loaded " + __libcluon.setMessageSpecification(odvd) + " messages from specification.");
        };


        var oldTimeStamp = 0;
        ws.onmessage = function(evt)
        {
            // This method will pass an OpenDaVINCI container to libcluon to parse it into a JSON object using the provided message specification.
            var data = JSON.parse(__libcluon.decodeEnvelopeToJSON(evt.data));
            console.log(data.dataType);
            if (data.dataType > 0)
            {
                if (oldTimeStamp == 0)
                {
                    oldTimeStamp = data.sampleTimeStamp.seconds * 1000 * 1000 + data.sampleTimeStamp.microseconds;
                }
                else
                {
                    var currentTimeStamp = data.sampleTimeStamp.seconds * 1000 * 1000 + data.sampleTimeStamp.microseconds;
                    dataLine.append(new Date().getTime(), Math.abs(currentTimeStamp - oldTimeStamp));
                    oldTimeStamp = currentTimeStamp;
                }
            }

            if (data.dataType == 1046)
            {
                gaugePS.value = data.opendlv_proxy_GroundSpeedReading.groundSpeed * 3.6;
            }
            if (data.dataType == 19)
            {
                var c = [data.opendlv_proxy_GeodeticWgs84Reading.longitude, data.opendlv_proxy_GeodeticWgs84Reading.latitude];
                map.setCenter(c);
            }
            if (data.dataType == 1193)
            {
                // CompactPointCloud
                var mapCoordinatesRaw = window.atob(data.opendlv_proxy_OrbslamMap.mapCoordinates);
                var cameraCoordinatesRaw = window.atob(data.opendlv_proxy_OrbslamMap.cameraCoordinates);
                console.log("got type 1193");
                var mapCoordinatesParsed = floatArrayFromString(mapCoordinatesRaw, 4, ':');
                var cameraCoordinatesParsed = floatArrayFromString(cameraCoordinatesRaw, 4, ':');
                var mappointsFromMap = mapPointsArrayFromFloatArray(mapCoordinatesParsed);
                var mappointsFromCamera = mapPointsArrayFromFloatArray(cameraCoordinatesParsed);
                
                //insertMapPoints(mappointsFromMap);
                insertCarPoints(mappointsFromCamera);
                // var mapPoints = [];
                // var direction = 0;
                // for (var i = 0; i < distances.length; i += 15) {
                //     for(var j = 0; j < i+11; j += 5) {
                //         var mapPoint = {};
                //         switch(direction){
                //             case 0:
                //                 mapPoint.x = parseFloat(distances[i+j]);
                //           cameraCoordinates      direction++;
                //                 break;
                //             case 1:
                //                 mapPoint.y = parseFloat();
                //                 direction++;
                //                 break;
                //             case 2:
                //                 mapPoint.z = parseFloat();
                //                 direction = 0;
                //                 break;
                //             default:
                //                 break;
                //         }
                //     }

                // }

                // for (var i = 0; i < distances.length; i += 12){
                //     for(var j = i; j < i+11; j += 4) {
                //         var data =  [distances[j], distances[j+1], distances[j+2], distances[j+3]];
                //         var buf = new ArrayBuffer(4);
                //         var view = new DataView(buf);
                //         data.forEach(function (b, i) {
                //             view.setUint8(i, b);
                //         });
                //         var num = view.getFloat32(0);
                //         console.log(num);
                //         // Done
                //         console.log(num);
                //     }
                // }


                // for(var i = 0; i < distances.length; i += 12)
                // {
                //     var data =  [distances[i], 226, 157, 10];
                    
                //     // Create a buffer
                //     var buf = new ArrayBuffer(4);
                //     // Create a data view of it
                //     var view = new DataView(buf);

                //     // set bytes
                //     data.forEach(function (b, i) {
                //         view.setUint8(i, b);
                //     });

                //     // Read the bits as a float; note that by doing this, we're implicitly
                //     // converting it from a 32-bit float into JavaScript's native 64-bit double
                //     var num = view.getFloat32(0);
                //     // Done
                //     console.log(num);
                //     var mapPoint = {};
                //     for(var j = 0; j < 3; j++)
                //     {
                //         var bits = (0xFF & distances[i + j]) << 24 | (0xFF & distances[i + j + 1]) << 16 | (0xFF & distances[i + j + 2]) << 8 | (0xFF & distances[i + j + 3]);
                //         var sign = ((bits >>> 31) == 0) ? 1.0 : -1.0;
                //         var e = ((bits >>> 23) & 0xff);
                //         var m = (e == 0) ? (bits & 0x7fffff) << 1 : (bits & 0x7fffff) | 0x800000;
                //         var f = sign * m * Math.pow(2, e - 150);

                //         if(j === 0)
                //         {
                //             mapPoint.x = f;
                //         }
                //         else if(j === 1)
                //         {
                //             mapPoint.y = f;
                //         }
                //         else if(j === 2)
                //         {
                //             mapPoint.z = f;
                //         }
                //     }
                //     console.log(mapPoint);
                //     mapPoints[i/4] = mapPoint;
                // }

                //console.log(mapPoints);
                //insertMapPoints(mapPoints);
            }
        };

        ws.onclose = function() {
            console.log("Connection is closed...");
            document.getElementById("connectionStatusText").style.color = "#555";
            document.getElementById("connectionStatusSymbol").style.color = "#555";
            document.getElementById("connectionStatusText").innerHTML = "disconnected";
        };

    }
    else
    {
        // The browser doesn't support WebSocket
        console.log("WebSocket NOT supported by your Browser!");
    }
</script>

<script>
var gaugePS = new RadialGauge({
    renderTo: 'speed',
   units: "kph",
    minValue: 0,
    maxValue: 220,
    majorTicks: [
        "0",
        "20",
        "40",
        "60",
        "80",
        "100",
        "120",
        "140",
        "160",
        "180",
        "200",
        "220"
    ],
    minorTicks: 2,
    strokeTicks: true,
    highlights: [
        {
            "from": 160,
            "to": 220,
            "color": "rgba(200, 50, 50, .75)"
        }
    ],
    colorPlate: "#fff",
    borderShadowWidth: 0,
    borders: false,
    needleType: "arrow",
    needleWidth: 2,
    needleCircleSize: 7,
    needleCircleOuter: true,
    needleCircleInner: false,
    animationDuration: 1500,
    animationRule: "linear"
});
gaugePS.draw();
//gaugePS.value = "510";
</script>


<script>
    var dataLine = new TimeSeries();

    var chart = new SmoothieChart({millisPerPixel:100,grid:{millisPerLine:3000,fillStyle:'#eee'},tooltip:true,maxValue:1000.0*1000.0,minValue:0}),
        canvas = document.getElementById('cpu-load'),
        line1 = dataLine;

        chart.addTimeSeries(line1, {lineWidth:2,strokeStyle:'rgba(20,20,20,0.55)',fillStyle:'rgba(123,41,0,0.30)'});
        chart.streamTo(canvas, 1237);

    // Add to SmoothieChart
    chart.addTimeSeries(dataLine);
</script>


<script>
var map = new maptalks.Map("map",{
    center : [-118.150127,33.779397],
    pitch : 0,
    bearing : 0,
    zoom : 14,
    centerCross: true,
    attribution : {
      'content' : '<span style="padding:4px"><font size=1>&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, &copy; <a href="https://carto.com/attributions">CARTO</a></font> </span>'
    },
// a custom version of default web-mercator spatial reference
        // map's spatial reference definition
        spatialReference : {
          projection : 'EPSG:3857', // geo projection, can be a string or a function
          resolutions : [           // map's zoom levels and resolutions
            156543.03392804097,
            78271.51696402048,
            9135.75848201024,
            19567.87924100512,
            9783.93962050256,
            4891.96981025128,
            2445.98490512564,
            1222.99245256282,
            611.49622628141,
            305.748113140705,
            152.8740565703525,
            76.43702828517625,
            38.21851414258813,
            19.109257071294063,
            9.554628535647032,
            4.777314267823516,
            2.388657133911758,
            1.194328566955879,
            0.5971642834779395,
            0.29858214173896974,
            0.1492910709,
            0.07464553543,
            0.03732276771
          ],
          fullExtent : {         // map's full extent
            'top': 6378137 * Math.PI,
            'left': -6378137 * Math.PI,
            'bottom': -6378137 * Math.PI,
            'right': 6378137 * Math.PI
          }
        },
        baseLayer : new maptalks.TileLayer('base',{
          urlTemplate: 'http://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png',
          subdomains: ['a','b','c','d'],
          tileSystem : [1, -1, -20037508.34, 20037508.34], // tile system
          minZoom : 1,
          maxZoom : 23
        })
});
</script>


<script>
    // var GL_position_index = 0;
    // // Setup look-up table for interleaved vertical layers.
    // var verticalAngles16 = [-15.0, -13.0, -11.0, -9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0, 11.0, 13.0, 15.0];
    // var verticalAngles12 = [-30.67, -29.33, -25.33, -21.32, -17.32, -13.31, -9.31, -5.3, -1.3, 2.71, 6.71, 10.72];
    // var verticalAngles11 = [-28.0, -26.66, -22.66, -18.65, -14.65, -10.64, -6.64, -2.63, 1.37, 5.38, 9.38];
    // var verticalAngles9 = [-23.99, -19.99, -15.98, -11.98, -7.97, -3.97, 0.04, 4.04, 8.05];
    //
    // var __libcluon = libcluon();
    //
    // function getResourceFrom(url) {
    //     var xmlHttp = new XMLHttpRequest();
    //     xmlHttp.open("GET", url, false /*asynchronous request*/);
    //     xmlHttp.send(null);
    //     return xmlHttp.responseText;
    // }
    //
    // if ("WebSocket" in window) {
    //     var ws = new WebSocket("ws://" + window.location.host + "/");
    //     ws.binaryType = 'arraybuffer';
    //
    //     ws.onopen = function() {
    //         console.log("Connected...");
    //         document.getElementById("connectionStatusSymbol").style.color = "#3CB371";
    //         document.getElementById("connectionStatusText").style.color = "#3CB371";
    //         document.getElementById("connectionStatusText").innerHTML = "connected";
    //         var odvd = getResourceFrom("opendlv-standard-message-set-v0.9.1.odvd");
    //         console.log("Loaded " + __libcluon.setMessageSpecification(odvd) + " messages from specification.");
    //     };
    //
    //
    //     var oldTimeStamp = 0;
    //     ws.onmessage = function(evt) {
    //         // This method will pass an OpenDaVINCI container to libcluon to parse it into a JSON object using the provided message specification.
    //         var data = JSON.parse(__libcluon.decodeEnvelopeToJSON(evt.data));
    //
    //         if (data.dataType > 0) {
    //             if (oldTimeStamp == 0) {
    //                 oldTimeStamp = data.sampleTimeStamp.seconds * 1000 * 1000 + data.sampleTimeStamp.microseconds;
    //             }
    //             else {
    //                 var currentTimeStamp = data.sampleTimeStamp.seconds * 1000 * 1000 + data.sampleTimeStamp.microseconds;
    //                 dataLine.append(new Date().getTime(), Math.abs(currentTimeStamp - oldTimeStamp));
    //                 oldTimeStamp = currentTimeStamp;
    //             }
    //         }
    //
    //         if (data.dataType == 1046) {
    //             gaugePS.value = data.opendlv_proxy_GroundSpeedReading.groundSpeed * 3.6;
    //         }
    //         if (data.dataType == 19) {
    //             var c = [data.opendlv_proxy_GeodeticWgs84Reading.longitude, data.opendlv_proxy_GeodeticWgs84Reading.latitude];
    //             map.setCenter(c);
    //         }
    //         if (data.dataType == 49) {
    //             // CompactPointCloud
    //             var distances = window.atob(data.opendlv_proxy_PointCloudReading.distances);
    //
    //             var startAzimuth = data.opendlv_proxy_PointCloudReading.startAzimuth;
    //             var endAzimuth = data.opendlv_proxy_PointCloudReading.endAzimuth;
    //             var entriesPerAzimuth = data.opendlv_proxy_PointCloudReading.entriesPerAzimuth;
    //             var numberOfPoints = distances.length / 2;
    //             var numberOfAzimuths = numberOfPoints / entriesPerAzimuth;
    //             var azimuthIncrement = (endAzimuth - startAzimuth) / numberOfAzimuths;
    //
    //             var GL_positions = particles_pointcloud.geometry.attributes.position.array;
    //
    //             // VLP16 sends 16 layers,
    //             if (16 == entriesPerAzimuth) {
    //                 GL_positions.fill(0);
    //                 GL_position_index = 0;
    //             }
    //             // HDL32e sends the sequence 12, 11, 9 layers.
    //             if (12 == entriesPerAzimuth) {
    //                 GL_positions.fill(0);
    //                 GL_position_index = 0;
    //             }
    //
    //             var index = 0;
    //             var azimuth = startAzimuth;
    //             for (var azimuthIndex = 0; azimuthIndex < numberOfAzimuths; azimuthIndex++) {
    //                 for (var sensorIndex = 0; sensorIndex < entriesPerAzimuth; sensorIndex++) {
    //                     var verticalAngle = 0;
    //                     if (16 == entriesPerAzimuth) {
    //                         verticalAngle = verticalAngles16[sensorIndex];
    //                     }
    //                     if (12 == entriesPerAzimuth) {
    //                         verticalAngle = verticalAngles12[sensorIndex];
    //                     }
    //                     if (11 == entriesPerAzimuth) {
    //                         verticalAngle = verticalAngles11[sensorIndex];
    //                     }
    //                     if (9 == entriesPerAzimuth) {
    //                         verticalAngle = verticalAngles9[sensorIndex];
    //                     }
    //
    //                     var byte0 = distances.charCodeAt(index++);
    //                     var byte1 = distances.charCodeAt(index++);
    //                     var distance = ( ((0xff & byte0) << 8) | (0xff & byte1) ) / 500.0;
    //                     if (distance > 1.0) {
    //                         var xyDistance = distance * Math.cos(verticalAngle * Math.PI/180.0);
    //                         var x = xyDistance * Math.sin(azimuth * Math.PI/180.0);
    //                         var y = xyDistance * Math.cos(azimuth * Math.PI/180.0);
    //                         var z = distance * Math.sin(verticalAngle * Math.PI/180.0);
    //                         if (GL_position_index < MAX_POINTS-3) {
    //                             GL_positions[GL_position_index++] = x;
    //                             GL_positions[GL_position_index++] = z;
    //                             GL_positions[GL_position_index++] = -y;
    //                         }
    //                     }
    //                 }
    //                 azimuth += azimuthIncrement;
    //             }
    //
    //             // Trigger update
    //             if ( (16 == entriesPerAzimuth)  ||
    //                  (9 == entriesPerAzimuth) ) {
    //                 particles_pointcloud.geometry.attributes.position.needsUpdate = true;
    //             }
    //         }
    //     };
    //
    //     ws.onclose = function() {
    //         console.log("Connection is closed...");
    //         document.getElementById("connectionStatusText").style.color = "#555";
    //         document.getElementById("connectionStatusSymbol").style.color = "#555";
    //         document.getElementById("connectionStatusText").innerHTML = "disconnected";
    //     };
    //
    // }
    // else {
    //     // The browser doesn't support WebSocket
    //     console.log("WebSocket NOT supported by your Browser!");
    // }
</script>

</html>

